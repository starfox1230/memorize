<!-- index.html -->

<!DOCTYPE html> 
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Memorize - Night Mode</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    /* Existing CSS */

    /* Add styles for the title input */
    .title-input {
      width: 100%;
      padding: 12px 15px;
      margin-bottom: 15px;
      border: 1px solid var(--input-border);
      border-radius: 6px;
      background-color: var(--input-bg);
      color: var(--text-color);
      font-size: 16px;
      transition: background-color 0.3s, color 0.3s, border 0.3s;
    }

    .title-input::placeholder {
      color: var(--secondary-text-color);
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Memorize</h1>

    <!-- New Title Input Field -->
    <input type="text" id="title-input" class="title-input" placeholder="Enter title here..." />

    <textarea id="text-input" placeholder="Enter text here..."></textarea>
    <br>
    <select id="voice-select">
      <option value="echo">Echo</option>
      <option value="alloy">Alloy</option>
      <option value="fable">Fable</option>
      <option value="onyx">Onyx</option>
      <option value="nova">Nova</option>
      <option value="shimmer">Shimmer</option>
      <!-- Add more voice options as per OpenAI's available voices -->
    </select>
    <button id="generate-btn">Generate Audio</button>

    <div class="audio-list" id="audio-list">
      <h2>Generated Audios</h2>
      <!-- Dynamic audio list will appear here -->
    </div>
  </div>

  <script>
    const generateBtn = document.getElementById('generate-btn');
    const textInput = document.getElementById('text-input');
    const titleInput = document.getElementById('title-input'); // <-- New title input
    const voiceSelect = document.getElementById('voice-select');
    const audioList = document.getElementById('audio-list');

    // Replace with your deployed backend URL on Render
    const BACKEND_URL = 'https://memorize-backend-lf3t.onrender.com'; 

    // Variable to keep track of the last interacted audio element
    let lastPlayedAudio = null;

    generateBtn.addEventListener('click', async () => {
      const title = titleInput.value.trim(); // <-- Get title
      const text = textInput.value.trim();
      const voice = voiceSelect.value;

      console.log('Generate Audio Button Clicked');
      console.log('Title:', title);
      console.log('Text:', text);
      console.log('Voice:', voice);

      if (!title || !text) { // <-- Validate title and text
        alert('Please enter both a title and some text.');
        return;
      }

      try {
        generateBtn.disabled = true;
        generateBtn.innerText = 'Generating...';
        console.log('Sending POST request to /generate-audio');

        const response = await fetch(`${BACKEND_URL}/generate-audio`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ title, text, voice }) // <-- Send title
        });

        console.log('Received response:', response);

        const data = await response.json();
        console.log('Response data:', data);

        if (response.ok) {
          alert('Audio generated successfully!');
          titleInput.value = ''; // <-- Clear title input
          textInput.value = '';
          fetchAudios();
        } else {
          alert(`Error: ${data.error}`);
        }
      } catch (error) {
        console.error('Error generating audio:', error);
        alert('Failed to generate audio.');
      } finally {
        generateBtn.disabled = false;
        generateBtn.innerText = 'Generate Audio';
      }
    });

    async function fetchAudios() {
      try {
        const res = await fetch(`${BACKEND_URL}/audios`);
        const audios = await res.json();

        audioList.innerHTML = '<h2>Generated Audios</h2>';
        audios.forEach(audio => {
          const audioItem = document.createElement('div');
          audioItem.className = 'audio-item';

          // Create Title Button
          const titleButton = document.createElement('button');
          titleButton.className = 'title-button';
          titleButton.textContent = audio.title;
          titleButton.style.marginRight = '10px';
          titleButton.style.padding = '10px 15px';
          titleButton.style.backgroundColor = 'var(--button-bg)';
          titleButton.style.color = 'var(--button-color)';
          titleButton.style.border = 'none';
          titleButton.style.borderRadius = '6px';
          titleButton.style.cursor = 'pointer';
          titleButton.style.fontSize = '16px';
          titleButton.style.transition = 'background-color 0.3s';
          titleButton.addEventListener('mouseover', () => {
            titleButton.style.backgroundColor = 'var(--button-hover-bg)';
          });
          titleButton.addEventListener('mouseout', () => {
            titleButton.style.backgroundColor = 'var(--button-bg)';
          });

          // Create a container for details (hidden by default)
          const detailsContainer = document.createElement('div');
          detailsContainer.style.display = 'none';
          detailsContainer.style.marginTop = '10px';

          const audioElement = document.createElement('audio');
          audioElement.controls = true;
          audioElement.src = audio.url;
          audioElement.loop = true; // Enable looping

          // Event listeners to update lastPlayedAudio when interacted with
          audioElement.addEventListener('play', () => {
            lastPlayedAudio = audioElement;
          });
          audioElement.addEventListener('pause', () => {
            lastPlayedAudio = audioElement;
          });
          audioElement.addEventListener('seeked', () => {
            lastPlayedAudio = audioElement;
          });
          audioElement.addEventListener('volumechange', () => {
            lastPlayedAudio = audioElement;
          });
          audioElement.addEventListener('ended', () => {
            lastPlayedAudio = audioElement;
          });

          const info = document.createElement('div');
          info.className = 'audio-info';
          const timestamp = audio.timestamp 
            ? new Date(audio.timestamp.seconds * 1000).toLocaleString() 
            : 'N/A';
          info.textContent = `${audio.text} (${timestamp})`;

          const deleteBtn = document.createElement('button');
          deleteBtn.className = 'delete-btn';
          deleteBtn.textContent = 'Delete';
          deleteBtn.addEventListener('click', () => deleteAudio(audio.id));

          // Append audio and info to details container
          detailsContainer.appendChild(audioElement);
          detailsContainer.appendChild(info);
          detailsContainer.appendChild(deleteBtn);

          // Toggle functionality
          titleButton.addEventListener('click', () => {
            if (detailsContainer.style.display === 'none') {
              detailsContainer.style.display = 'block';
            } else {
              detailsContainer.style.display = 'none';
            }
          });

          audioItem.appendChild(titleButton);
          audioItem.appendChild(detailsContainer);
          audioList.appendChild(audioItem);
        });
      } catch (error) {
        console.error('Error fetching audios:', error);
      }
    }

    async function deleteAudio(id) {
      if (!confirm('Are you sure you want to delete this audio?')) {
        return;
      }

      try {
        const response = await fetch(`${BACKEND_URL}/delete-audio`, {
          method: 'DELETE',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ id })
        });

        const data = await response.json();
        console.log('Delete response:', data);

        if (response.ok) {
          alert('Audio deleted successfully!');
          fetchAudios();
        } else {
          alert(`Error: ${data.error}`);
        }
      } catch (error) {
        console.error('Error deleting audio:', error);
        alert('Failed to delete audio.');
      }
    }

    // Fetch audios on page load
    window.onload = fetchAudios;

    // Keyboard Shortcuts Implementation
    document.addEventListener('keydown', function(event) {
      // Check if there is a last interacted audio element
      if (!lastPlayedAudio) return;

      const key = event.key;

      // Define actions for specific keys
      switch(key) {
        case 'ArrowLeft':
          // Rewind 10 seconds
          event.preventDefault(); // Prevent default browser behavior
          lastPlayedAudio.currentTime = Math.max(0, lastPlayedAudio.currentTime - 10);
          break;
        case 'ArrowRight':
          // Fast forward 10 seconds
          event.preventDefault(); // Prevent default browser behavior
          lastPlayedAudio.currentTime = Math.min(lastPlayedAudio.duration, lastPlayedAudio.currentTime + 10);
          break;
        case ' ':
        case 'Spacebar': // For older browsers
          // Play/Pause toggle
          event.preventDefault(); // Prevent default browser behavior (like scrolling)
          if (lastPlayedAudio.paused) {
            lastPlayedAudio.play();
          } else {
            lastPlayedAudio.pause();
          }
          break;
        default:
          // Do nothing for other keys
          break;
      }
    });
  </script>

</body>
</html>
